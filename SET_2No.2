SET_2 No.2

import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.LinkedList;
import java.util.List;

import org.cloudbus.cloudsim.Cloudlet;
import org.cloudbus.cloudsim.CloudletSchedulerTimeShared;
import org.cloudbus.cloudsim.Datacenter;
import org.cloudbus.cloudsim.DatacenterBroker;
import org.cloudbus.cloudsim.DatacenterCharacteristics;
import org.cloudbus.cloudsim.Host;
import org.cloudbus.cloudsim.Log;
import org.cloudbus.cloudsim.Pe;
import org.cloudbus.cloudsim.Storage;
import org.cloudbus.cloudsim.UtilizationModel;
import org.cloudbus.cloudsim.UtilizationModelFull;
import org.cloudbus.cloudsim.Vm;
import org.cloudbus.cloudsim.VmAllocationPolicySimple;
import org.cloudbus.cloudsim.VmSchedulerSpaceShared;
import org.cloudbus.cloudsim.core.CloudSim;
import org.cloudbus.cloudsim.provisioners.BwProvisionerSimple;
import org.cloudbus.cloudsim.provisioners.PeProvisionerSimple;
import org.cloudbus.cloudsim.provisioners.RamProvisionerSimple;

public class EnhancedCloudSimSimulation {
    // Simulation Configuration Constants
    private static final int NUM_DATACENTERS = 8;
    private static final int HOSTS_PER_DATACENTER = 8;
    private static final int VMS_PER_DATACENTER = 5;
    private static final int CLOUDLETS_PER_DATACENTER = 3;

    // VM and Cloudlet Configuration
    private static final int MIPS = 1000;
    private static final int RAM = 2048;
    private static final long STORAGE = 1000000;
    private static final int BANDWIDTH = 10000;

    // Simulation Lists
    private static List<Cloudlet> cloudletList;
    private static List<Vm> vmList;
    private static List<Datacenter> datacenterList;

    public static void main(String[] args) {
        Log.printLine("Starting Enhanced CloudSim Simulation...");

        try {
            // Initialize CloudSim
            int num_user = 1;
            Calendar calendar = Calendar.getInstance();
            boolean trace_flag = false;
            CloudSim.init(num_user, calendar, trace_flag);

            // Create Broker
            DatacenterBroker broker = createBroker();
            int brokerId = broker.getId();

            // Create Datacenters, VMs, and Cloudlets
            datacenterList = createDatacenters();
            vmList = createVirtualMachines(brokerId);
            cloudletList = createCloudlets(brokerId);

            // Submit VM and Cloudlet lists to broker
            broker.submitVmList(vmList);
            broker.submitCloudletList(cloudletList);

            // Bind cloudlets to VMs (round-robin approach)
            bindCloudletsToVMs(broker);

            // Start Simulation
            CloudSim.startSimulation();

            // Retrieve and print results
            List<Cloudlet> newList = broker.getCloudletReceivedList();
            CloudSim.stopSimulation();

            printCloudletList(newList);
            printPerformanceMetrics(newList);

            Log.printLine("Enhanced CloudSim Simulation finished!");
        }
        catch (Exception e) {
            e.printStackTrace();
            Log.printLine("Simulation terminated due to an unexpected error");
        }
    }

    private static List<Datacenter> createDatacenters() {
        List<Datacenter> datacenters = new ArrayList<>();
        for (int i = 0; i < NUM_DATACENTERS; i++) {
            datacenters.add(createDatacenter("Datacenter_" + i));
        }
        return datacenters;
    }

    private static Datacenter createDatacenter(String name) {
        List<Host> hostList = new ArrayList<>();

        for (int hostId = 0; hostId < HOSTS_PER_DATACENTER; hostId++) {
            List<Pe> peList = new ArrayList<>();
            peList.add(new Pe(0, new PeProvisionerSimple(MIPS)));

            Host host = new Host(
                hostId,
                new RamProvisionerSimple(RAM),
                new BwProvisionerSimple(BANDWIDTH),
                STORAGE,
                peList,
                new VmSchedulerSpaceShared(peList)
            );
            hostList.add(host);
        }

        String arch = "x86";
        String os = "Linux";
        String vmm = "Xen";
        double time_zone = 10.0;
        double cost = 3.0;
        double costPerMem = 0.05;
        double costPerStorage = 0.001;
        double costPerBw = 0.0;
        LinkedList<Storage> storageList = new LinkedList<>();

        DatacenterCharacteristics characteristics = new DatacenterCharacteristics(
            arch, os, vmm, hostList, time_zone, cost, costPerMem, costPerStorage, costPerBw);

        Datacenter datacenter = null;
        try {
            datacenter = new Datacenter(name, characteristics, 
                new VmAllocationPolicySimple(hostList), storageList, 0);
        } catch (Exception e) {
            e.printStackTrace();
        }

        return datacenter;
    }

    private static List<Vm> createVirtualMachines(int brokerId) {
        List<Vm> vms = new ArrayList<>();
        
        for (int dcId = 0; dcId < NUM_DATACENTERS; dcId++) {
            for (int vmId = 0; vmId < VMS_PER_DATACENTER; vmId++) {
                Vm vm = new Vm(
                    vms.size(), 
                    brokerId, 
                    MIPS, 
                    1,  // PEs
                    RAM, 
                    BANDWIDTH, 
                    10000,  // storage 
                    "Xen", 
                    new CloudletSchedulerTimeShared()
                );
                vms.add(vm);
            }
        }
        
        return vms;
    }

    private static List<Cloudlet> createCloudlets(int brokerId) {
        List<Cloudlet> cloudlets = new ArrayList<>();
        
        for (int dcId = 0; dcId < NUM_DATACENTERS; dcId++) {
            for (int cloudletId = 0; cloudletId < CLOUDLETS_PER_DATACENTER; cloudletId++) {
                UtilizationModel utilizationModel = new UtilizationModelFull();
                
                Cloudlet cloudlet = new Cloudlet(
                    cloudlets.size(), 
                    40000,  // length
                    1,      // PEs
                    300,    // fileSize
                    300,    // outputSize
                    utilizationModel, 
                    utilizationModel, 
                    utilizationModel
                );
                cloudlet.setUserId(brokerId);
                cloudlets.add(cloudlet);
            }
        }
        
        return cloudlets;
    }

    private static void bindCloudletsToVMs(DatacenterBroker broker) {
        for (int i = 0; i < cloudletList.size(); i++) {
            broker.bindCloudletToVm(
                cloudletList.get(i).getCloudletId(), 
                vmList.get(i % vmList.size()).getId()
            );
        }
    }

    private static DatacenterBroker createBroker() {
        DatacenterBroker broker = null;
        try {
            broker = new DatacenterBroker("Enhanced_Broker");
        } catch (Exception e) {
            e.printStackTrace();
        }
        return broker;
    }

    private static void printCloudletList(List<Cloudlet> list) {
        int size = list.size();
        Cloudlet cloudlet;

        String indent = "    ";
        Log.printLine("\n========== CLOUDLET EXECUTION DETAILS ==========");
        Log.printLine("Cloudlet ID" + indent + "STATUS" + indent +
                "Data center ID" + indent + "VM ID" + indent + 
                "Time" + indent + "Start Time" + indent + "Finish Time");

        DecimalFormat dft = new DecimalFormat("###.##");
        for (int i = 0; i < size; i++) {
            cloudlet = list.get(i);
            if (cloudlet.getCloudletStatus() == Cloudlet.SUCCESS) {
                Log.printLine(
                    indent + cloudlet.getCloudletId() + 
                    indent + indent + "SUCCESS" +
                    indent + indent + cloudlet.getResourceId() + 
                    indent + indent + indent + cloudlet.getVmId() +
                    indent + indent + dft.format(cloudlet.getActualCPUTime()) +
                    indent + indent + dft.format(cloudlet.getExecStartTime()) +
                    indent + indent + dft.format(cloudlet.getFinishTime())
                );
            }
        }
    }

    private static void printPerformanceMetrics(List<Cloudlet> cloudlets) {
        Log.printLine("\n========== PERFORMANCE METRICS ==========");
        
        // Total Execution Time
        double maxFinishTime = cloudlets.stream()
            .mapToDouble(Cloudlet::getFinishTime)
            .max()
            .orElse(0.0);
        Log.printLine("Total Execution Time: " + maxFinishTime + " seconds");

        // Average Cloudlet Execution Time
        double avgExecutionTime = cloudlets.stream()
            .mapToDouble(Cloudlet::getActualCPUTime)
            .average()
            .orElse(0.0);
        Log.printLine("Average Cloudlet Execution Time: " + avgExecutionTime + " seconds");

        // Network Latency Impact (simplified estimation)
        long totalCloudlets = cloudlets.size();
        long successfulCloudlets = cloudlets.stream()
            .filter(c -> c.getCloudletStatus() == Cloudlet.SUCCESS)
            .count();
        
        Log.printLine("Total Cloudlets: " + totalCloudlets);
        Log.printLine("Successfully Executed Cloudlets: " + successfulCloudlets);
    }
}
